// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/

// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/

// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/

// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/

// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/

// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/

// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/

// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/


// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/


// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/


// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/


// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/


// Created by Y. Sendov. November 2021

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <locale.h>

// ----------------------------------------------------------------

// Создание структуры для хранения длинного числа
typedef struct bigint
{
    int i_sign;
    int i_n;
    int* i_numbers;
} bigint;

// Создание числа bigint на n элементов со знаком sign
bigint bi_create(int n, int sign) 
{
    bigint value;
    value.i_n = n;
    value.i_numbers = (int*)calloc(n, sizeof(int));
    value.i_sign = sign;
    return value;
} 

// Единица, записанная в структуре bigint
bigint bi_unit() 
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Ноль, записанный в структуре bigint
bigint bi_zero()
{
    bigint unit = bi_create(1, 1);
    unit.i_numbers[0] = 0;
    return unit;
}

// Минус единица, записанная в структуре bigint
bigint bi_miunit()
{
    bigint unit = bi_create(1, -1);
    unit.i_numbers[0] = 1;
    return unit;
}

// Очищение числа структуры bigint
bigint bi_clear(bigint value) 
{
    while (value.i_n > 1 && value.i_numbers[value.i_n - 1] == 0)
    {
        value.i_n--;
    }
    if (value.i_n == 1 && value.i_numbers[0] == 0)
    {
        value.i_sign = 1;
    }
    return value;
}

// Добавить элемент в число bigint
bigint bi_element(bigint value, char x) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    for (int i = value.i_n - 2; i >= 0; i--) 
    {
        value.i_numbers[i + 1] = value.i_numbers[i];
    }
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Инициализировать число bigint с помощью считанного символа
bigint bi_init_value(char x) 
{
    bigint value;
    value.i_sign = 1;
    value.i_n = 1;
    value.i_numbers = NULL;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[0] = x - '0';
    return bi_clear(value);
}

// Максимум из чисел x и y
int i_max(int x, int y)
{
    return x > y ? x : y;
}

// Сравнение двух чисел bigint
int i_compare(bigint value1, bigint value2)
{
    if (value1.i_sign != value2.i_sign)
    {
        return value1.i_sign > value2.i_sign;
    }
    if (value1.i_n != value2.i_n)
    {
        return value1.i_sign == 1 ? value1.i_n > value2.i_n : value1.i_n < value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_sign == 1 ? value1.i_numbers[i] > value2.i_numbers[i] : value1.i_numbers[i] < value2.i_numbers[i];
        }
    }
    return 0;
}

// Сравнение двух чисел bigint по модулю
int i_module_compare(bigint value1, bigint value2)
{
    if (value1.i_n != value2.i_n)
    {
        return value1.i_n > value2.i_n;
    }
    for (int i = value1.i_n - 1; i >= 0; i--)
    {
        if (value1.i_numbers[i] != value2.i_numbers[i])
        {
            return value1.i_numbers[i] > value2.i_numbers[i];
        }
    }
    return 0;
}

// Вывод в консоль числа bigint
void bi_printf(bigint value) 
{
    if (value.i_sign == -1)
    {
        printf("-");
    }
    for (int i = value.i_n - 1; i >= 0; i--)
    {
        printf("%d", value.i_numbers[i]);
    }
}

// ----------------------------------------------------------------

bigint bi_diff(bigint value1, bigint value2);

// Сумма двух bigint чисел
bigint bi_sum(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint summ = bi_diff(value1, value2);
        value2.i_sign = -1;
        return summ;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint summ = bi_diff(value2, value1);
        value1.i_sign = -1;
        return summ;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint summ = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        summ.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        summ.i_numbers[i] += value2.i_numbers[i];
    }
    for (int i = 0; i < summ.i_n - 1; i++) 
    {
        summ.i_numbers[i + 1] += (summ.i_numbers[i] / 10);
        summ.i_numbers[i] %= 10;
    }
    return bi_clear(summ);
}

// Разность двух bigint чисел
bigint bi_diff(bigint value1, bigint value2)
{
    if (value1.i_sign == 1 && value2.i_sign == -1)
    {
        value2.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value2.i_sign = -1;
        return sub;
    }
    if (value1.i_sign == -1 && value2.i_sign == 1)
    {
        value1.i_sign = 1;
        bigint sub = bi_sum(value1, value2);
        value1.i_sign = -1;
        sub.i_sign = -1;
        return sub;
    }
    if (i_module_compare(value2, value1))
    {
        bigint sub = bi_diff(value2, value1);
        sub.i_sign = -sub.i_sign;
        return sub;
    }

    int n = i_max(value1.i_n, value2.i_n) + 1;
    bigint sub = bi_create(n, value1.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        sub.i_numbers[i] = value1.i_numbers[i];
    }
    for (int i = 0; i < value2.i_n; i++)
    {
        sub.i_numbers[i] -= value2.i_numbers[i];
    }
    for (int i = 0; i < sub.i_n - 1; i++)
    {
        if (sub.i_numbers[i] < 0)
        {
            sub.i_numbers[i] += 10;
            sub.i_numbers[i + 1]--;
        }
    }
    return bi_clear(sub);
}

// Умножение двух bigint чисел
bigint bi_mult(bigint value1, bigint value2)
{
    int n = value1.i_n + value2.i_n;
    bigint mult = bi_create(n, value1.i_sign * value2.i_sign);

    for (int i = 0; i < value1.i_n; i++)
    {
        for (int j = 0; j < value2.i_n; j++)
        {
            mult.i_numbers[i + j] += value1.i_numbers[i] * value2.i_numbers[j];
        }
    }
    for (int i = 0; i < mult.i_n - 1; i++) 
    {
        mult.i_numbers[i + 1] += mult.i_numbers[i] / 10;
        mult.i_numbers[i] %= 10;
    }
    return bi_clear(mult);
}

// Возведение числа bigint в степень bigint
bigint bi_degree(bigint value1, bigint value2) 
{
    if (value2.i_n == 1) 
    {
        if (value2.i_numbers[0] == 0) 
        {
            return bi_unit();
        }
        if (value2.i_numbers[0] == 1) 
        {
            return value1;
        }
    }
    bigint result = bi_unit();
    for (bigint i = bi_zero(); i_module_compare(value2, i); i = bi_sum(i, bi_unit())) 
    {
        result = bi_mult(result, value1);
    }
    return result;
}

// Функция для получения числа bigint, следующего за текущим
bigint bi_next(bigint value) 
{
    value.i_n++;
    value.i_numbers = (int*)realloc(value.i_numbers, value.i_n * sizeof(int));
    value.i_numbers[value.i_n - 1] = 0;

    if (value.i_sign > 0)
    {
        value.i_numbers[0]++;
        for (int k = 0; k < value.i_n && value.i_numbers[k] > 9; k++)
        {
            value.i_numbers[k] = 0;
            value.i_numbers[k + 1]++;
        }
    }
    else 
    {
        value.i_numbers[0]--;
        for (int k = 0; k < value.i_n && value.i_numbers[k] < 0; k++)
        {
            value.i_numbers[k] += 10;
            value.i_numbers[k + 1]--;
        }
    }
    return bi_clear(value);
}

// Вычисление факториала числа bigint
bigint factorial(bigint value)
{
    bigint result = bi_unit();
    for (bigint i = bi_unit(); !i_compare(i, value); i = bi_next(i))
    {
        result = bi_mult(result, i);
    }
    return result;
}

// ----------------------------------------------------------------

// Значения для текущего выражения (то есть, изначально первого)
int i_counter = 1;
int i_correct = 1;

// Создание структуры стека для хранения знаков операций
typedef struct int_stack 
{
    int data[500];
    size_t size; // Количество элементов, и указатель на вершину стека
} i_stack;

// Функция добавления нового элемента в стек
void push_i(i_stack* stack, const int value) 
{
    if (stack->size >= 500) // Проверка на переполнение стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1); 
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
int pop_i(i_stack* stack)
{
    if (stack->size == 0)  // Проверка на снятие элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
int peek_i(const i_stack* stack)
{
    if (stack->size <= 0) // Проверка на просмотр элемента с пустого стека
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Создание структуры стека для хранения чисел bigint
typedef struct bigint_stack
{
    bigint data[2000];
    size_t size;
} bi_stack;

// Функция добавления нового элемента в стек
void push_bi(bi_stack* stack, const bigint value)
{
    if (stack->size >= 2000)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-1);
    }
    stack->data[stack->size] = value;
    stack->size++;
}

// Функция взятия верхнего элемента из стека
bigint pop_bi(bi_stack* stack)
{
    if (stack->size == 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    stack->size--;
    return stack->data[stack->size];
}

// Функция просмотра верхнего элемента в стеке
bigint peek_bi(const bi_stack* stack)
{
    if (stack->size <= 0)
    {
        i_correct = 0;
        printf("Выражение %d. Некорректно\n", i_counter);
        exit(-2);
    }
    return stack->data[stack->size - 1];
}

// ----------------------------------------------------------------

// Функция реализации приоритета операций
int i_priority(char x) 
{
    switch (x)
    {
        case '+':
            return 1;
        case '-':
            return 1;
        case '*':
            return 2;
        case '^':
            return 3;
        case '!':
            return 4;
        case '(':
            return 0;
        case ')':
            return 0;
        default:
            printf("Выражение %d. Некорректно\n", i_counter);
            return 0;
    }
}

int i_check_input(char x) 
{
    if (x >= '0' && x <= '9') 
    { 
        return 1; 
    }
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n') 
    {
        return 1;
    }
    return 0;
}

int i_check_act(char x)
{
    if (x == '!' || x == '+' || x == '-' || x == '(' || x == ')' || x == '*' || x == '^' || x == '\\' || x == '\n')
    {
        return 1;
    }
    return 0;
}

int i_check_num(char x) 
{
    if (x >= '0' && x <= '9') 
    {
        return 1;
    }
    else 
    {
        return 0;
    }
}

// Функция просчёта определенных операций с числами bigint
bigint calculator(bigint value1, bigint value2, char op)
{
    switch (op)
    {
        case '+':
            return bi_sum(value1, value2);
        case '-':
            return bi_diff(value1, value2);
        case '*':
            return bi_mult(value1, value2);
        case '^':
            return bi_degree(value1, value2);
        default:
            return bi_unit();
    }
}

// ----------------------------------------------------------------

FILE* stream;

void v_openfile()
{
    setlocale(LC_ALL, "Rus");
	printf("Введите имя файла с расширением .txt: ");
	char filename[128];
	fgets(filename, sizeof(filename), stdin);
	filename[strcspn(filename, "\n")] = 0;
	errno_t error;
	error = fopen_s(&stream, filename, "r");

	if (error == 0)
	{
		printf("Файл '%s' был открыт.\n", filename);
	}
	else
	{
		printf("Файл '%s' не был открыт.\n", filename);
		v_openfile();
	}
}

int main()
{
	v_openfile();

    char a_str[6000];
    int i_flag = 0; // Маркер какого-либо выполненного действия, 0 - действий не было, 1 - были какие-либо действия
    int i_counter_open = 0; // Количество открывающих скобок (
    int i_counter_close = 0; // Количество закрывающих скобок )
    int i_last = 0; // Индекс последнего записанного в стек числа
    int i_slash = 0; // Маркер переноса строки символом backslash
    i_correct = 1; // Маркер корректности текущего выражения

    bi_stack stack_bigint;
    i_stack stack_act;

    stack_bigint.size = 0; // Обнуление значения size стека (т.к. у нас нет функции создания стека, необходимо обнулять вручную)
    stack_act.size = 0;
    
    while (fgets(a_str, sizeof(a_str), stream) != NULL)
    {
        if (i_slash == 1)
        {
            i_slash = 0;
        }
        else
        {
            i_correct = 1;
            i_flag = 0;
            i_counter_open = 0;
            i_counter_close = 0;
            i_last = 0;
            stack_bigint.size = 0;
            stack_act.size = 0;
        }

        for (int i = 0; i < 6000 || a_str[i] != '\n'; i++)
        {
            // Игнорирование пробелов в строке
            if (a_str[i] == ' ')
            {
                continue;
            }
            // Проверка на корректность выражения (отсутствие лишних символов)
            if (i_check_input(a_str[i]) == 0)
            {
                i_correct = 0;
                printf("Выражение %d. Некорректно\n", i_counter);
                i_counter += 1;
                break;
            }
            // Проверка на перенос выражения на другую строку
            if (a_str[i] == '\\') 
            {
                i_slash = 1;
                break;
            }
            // Парсинг чисел
            if ('0' <= a_str[i] && a_str[i] <= '9') 
            {
                i_flag = 1;
                if (stack_bigint.size == 0) 
                {
                    bigint value = bi_init_value(a_str[i]);
                    push_bi(&stack_bigint, value);
                    i_last = i;
                }
                else 
                {
                    i_flag = 1;
                    if (i - i_last == 1)
                    {
                        bigint last_value = pop_bi(&stack_bigint);
                        last_value = bi_element(last_value, a_str[i]);
                        push_bi(&stack_bigint, last_value);
                        i_last = i;
                    }
                    else 
                    {
                        i_flag = 1;
                        bigint value = bi_init_value(a_str[i]);
                        push_bi(&stack_bigint, value);
                        i_last = i;
                    }

                }
            }
            // Парсинг знака числового значения
            else if (a_str[i] == '-' && i == 0) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            else if (a_str[i] == '-' && !i_check_num(a_str[i - 1])) 
            {
                i_flag = 1;
                push_i(&stack_act, '*');
                push_bi(&stack_bigint, bi_miunit());
                i_last = 99999;
                continue;
            }
            // Парсинг скобок
            // Открывающая скобка
            else if (a_str[i] == '(') 
            {
                i_flag = 1;
                if (i != 0) 
                {
                    if (i_check_num(a_str[i - 1]) == 1) 
                    {
                        if (i_correct == 1) 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                        }
                        break;
                    }
                }
                i_flag = 1;
                push_i(&stack_act, '(');
                i_counter_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (a_str[i] == ')') 
            {
                i_flag = 1;
                if (i_counter_open == 0) 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
                else 
                {
                    while (peek_i(&stack_act) != '(') 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    pop_i(&stack_act);
                }
            }
            // Парсинг факториала
            else if (a_str[i] == '!')
            {
                i_flag = 1;
                if ((a_str[i - 1] <= '9' && a_str[i - 1] >= '0') || a_str[i - 1] == ')')
                {
                    push_bi(&stack_bigint, factorial(pop_bi(&stack_bigint)));
                    continue;
                }
                else 
                {
                    if (i_correct == 1) 
                    {
                        i_correct = 0;
                        printf("Выражение %d. Некорректно\n", i_counter);
                        i_counter += 1;
                    }
                    break;
                }
            }
            // Проведение математический операций
            else
            {
                if (a_str[i] == '\n')
                {
                    if (i_flag == 0) 
                    { 
                        break; 
                    }
                    while (stack_act.size != 0) 
                    {
                        bigint value1, value2;
                        char act;
                        if (stack_act.size >= 1 && stack_bigint.size >= 2) 
                        {
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                            continue;
                        }
                        else 
                        {
                            i_correct = 0;
                            printf("Выражение %d. Некорректно\n", i_counter);
                            i_counter += 1;
                            break;
                        }
                    }
                    break;
                }
                if (stack_act.size == 0) 
                {
                    i_flag += 1;
                    push_i(&stack_act, a_str[i]);
                }
                else 
                {
                    i_flag = 1;
                    if (i_priority(a_str[i]) > i_priority(peek_i(&stack_act))) 
                    {
                        push_i(&stack_act, a_str[i]);
                    }
                    else 
                    {
                        int i_true = 1;
                        while (i_true) 
                        {
                            if (stack_act.size == 0) 
                            {
                                break;
                            }
                            if (i_priority(peek_i(&stack_act)) < i_priority(a_str[i])) 
                            {
                                break;
                            }
                            bigint value1, value2;
                            char act;
                            value2 = pop_bi(&stack_bigint);
                            value1 = pop_bi(&stack_bigint);
                            act = pop_i(&stack_act);
                            push_bi(&stack_bigint, calculator(value1, value2, act));
                        }
                        push_i(&stack_act, a_str[i]);
                    }
                }
            }
        }
        if (i_flag && !i_slash && i_correct) 
        {
            printf("Выражение %d. Ответ: ", i_counter);
            bi_printf(peek_bi(&stack_bigint));
            printf("\n");
            i_counter += 1;
        }
    }
    fclose(stream);
	return 0;
}

/*
    while (fgets(input, sizeof(input), stream) != NULL)
    {
        if (slash == 1)
        {
            slash = 0;
        }
        else
        {
            flag = 0;
            count_open = 0, count_close = 0;
            index_last_number = 0;
            stack_num.size = 0;
            stack_op.size = 0;
            is_correct = 1;
            //
            number1.n = 0;
            number1.numbers = NULL;
            number1.sign = 1;

            stack_bignum.size = 0;

            number2.n = 0;
            number2.numbers = NULL;
            number2.sign = 1;
        }
        // Построчно
        for (int i = 0; i < 6000 || input[i] != 10; i++) // i < 2500
        {
            // Игнорирование пробелов
            if (input[i] == ' ')
            {
                continue;
            }
            // Выражение неверное
            if (check_input(input[i]) == 0)
            {
                printf("Выражение %d. Некорректно\n", a);
                is_correct = 0;
                a++;
                break;
            }
            // Проверка на перенос строки backslash'ом
            if (input[i] == '\\')
            {
                slash = 1;
                break;
            }
            // Парсинг числа
            if ('0' <= input[i] && input[i] <= '9')
            {
                flag = 1;
                if (stack_bignum.size == 0)
                {
                    for (int j = i; j < 2500 + i; j++)
                    {
                        if (input[j - 1] == '-')
                        {
                            number1.sign = -1;
                        }
                        if (check_num(input[j]) == 0)
                        {
                            break;
                        }
                        number1.n++;
                        number1.numbers = (int*)realloc(number1.numbers, number1.n * sizeof(int));
                        number1.numbers[number1.n - 1] = input[j] - '0';
                    }
                    for (int m = 0, k = number1.n - 1; m < k; m++, k--)
                    {
                        int digit = number1.numbers[m];
                        number1.numbers[m] = number1.numbers[k];
                        number1.numbers[k] = digit;
                    }
                    push_bi(&stack_bignum, number1);
                }
                /*
                flag = 1;
                if (stack_num.size == 0)
                {
                    push_i(&stack_num, input[i] - '0');
                    index_last_number = i;
                }
                else
                {
                    flag = 1;
                    if (i - index_last_number == 1)
                    {
                        int last_number = pop_i(&stack_num);
                        char temp[2500];
                        sprintf(temp, "%d", last_number);
                        push_i(&stack_num, atoi(strncat(temp, &input[i], 1)));
                        index_last_number = i;
                    }
                    else
                    {
                        flag = 1;
                        push_i(&stack_num, input[i] - '0');
                        index_last_number = i;
                    }
                }
            }

            // Парсинг скобок
            // Открывающая скобка
            else if (input[i] == '(')
            {
                flag = 1;
                if (i != 0)
                {
                    if (check_num(input[i - 1]) == 1)
                    {
                        if (is_correct == 1)
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            is_correct = 0;
                            a++;
                        }
                        break;
                    }
                }
                flag = 1;
                push_i(&stack_op, '(');
                count_open += 1;
                continue;
            }
            // Закрывающая скобка
            else if (input[i] == ')')
            {
                flag = 1;
                if (count_open == 0)
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
                else
                {
                    while (peek_i(&stack_op) != '(')
                    {
                        int x1, x2; // Цифры
                        char opp; // Знак
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            opp = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, opp));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    pop_i(&stack_op);
                }
            }
            // Факториал числа
            /*else if (input[i] == '!')
            {
                if (input[i - 1] <= '9' && input[i - 1] >= '0')
                {
                    push_i(&stack_num, fact(pop_i(&stack_num)));
                    continue;
                }
                else
                {
                    if (is_correct == 1)
                    {
                        printf("Выражение %d. Некорректно\n", a);
                        a++;
                        is_correct = 0;
                    }
                    break;
                }
            }
            // Вычисления
            else
            {
                if (input[i] == 10)
                {
                    if (flag == 0)
                    {
                        break;
                    }
                    while (stack_op.size != 0)
                    {
                        int x1, x2;
                        char op;
                        if (stack_op.size >= 1 && stack_num.size >= 2)
                        {
                            op = pop_i(&stack_op);
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            push_i(&stack_num, calculator(x1, x2, op));
                            continue;
                        }
                        else
                        {
                            printf("Выражение %d. Некорректно\n", a);
                            a++;
                            is_correct = 0;
                            break;
                        }
                    }
                    break;
                }
                if (stack_op.size == 0)
                {
                    flag += 1;
                    push_i(&stack_op, input[i]);
                }
                else
                {
                    flag = 1;
                    if (preor(input[i]) > (preor(peek_i(&stack_op))))
                    {
                        push_i(&stack_op, input[i]);
                    }
                    else
                    {
                        while (1)
                        {
                            if (stack_op.size == 0)
                            {
                                break;
                            }
                            if (preor(peek_i(&stack_op)) < preor(input[i]))
                            {
                                break;
                            }
                            int x1, x2;
                            char op;
                            x1 = pop_i(&stack_num);
                            x2 = pop_i(&stack_num);
                            op = pop_i(&stack_op);
                            push_i(&stack_num, calculator(x1, x2, op));
                        }
                        push_i(&stack_op, input[i]);
                    }
                }
            }
        }

        if (flag && !slash && is_correct)
        {
            printf("Выражение %d. Ответ: %d\n", a, stack_num.data[0]);
            a++;
        }
    }*/